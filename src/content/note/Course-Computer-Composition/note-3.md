---
title: "Computer Composition Review Ch3 存储系统"
date: 2024-06-16
---

## 3.1 存储系统概述
### 3.1.1 存储系统的层次结构
- 程序的局部性原理
	- 在某一段时间内频繁访问某一局部的存储器地址空间，而对此范围外的地址空间则很少访问。
	- 空间局部性
		- 最近被访问的信息邻近地址的信息也可能被访问。
	- 时间局部性
		- 最近被访问的信息很可能还要被访问。
- 多级存储系统的组成
	- 两级存储系统
		- 内存储器
			- 存放正在执行的程序指令和数据，供 CPU 直接访问。
			- 半导体
			- 速度高
			- 容量小
			- 价格高
		- 外存储器/辅助存储器
			- 外存信息调入内存后，CPU 才能处理。
			- 磁盘、光盘...
			- 速度低
			- 容量大
			- 价格低
	- 三级存储系统
		- ![三级存储系统组成|280](https://cdn.jsdelivr.net/gh/aBER0724/ob_picture/Img/20240605092705.png)
		- 高速缓冲存储器（cache）
			- 内存储器与 CPU 之间，存放一些信息块的副本。
			- 速度更高
			- 容量更小
		- 各个存储器作用
			- 主存（常规内存）
				- 容纳系统的核心软件和较多的用户程序。
			- 外存
				- 满足大量存储需求。
			- cache
				- 匹配存取速度和 CPU 运算速度。
- 多级存储系统的金字塔结构
	- ![多级存储系统的金字塔结构|279](https://cdn.jsdelivr.net/gh/aBER0724/ob_picture/Img/20240605093038.png)
### 3.1.2 存储器分类
- 存储位元
	- 存储器最小的存储单元。
	- 存储位元 → 存储单元 → 存储器
- 存储介质分类
	- 半导体存储器
	- 存储量大，信息不易丢失
		- 磁表面存储器
			- 磁带，磁盘
		- 光存储器
			- 光盘
- 存取方式分类
	- 随机存取存储器
	- 顺序存取存储器
		- 只能按某种顺序来存取
		- 存取时间与存储单元的物理位置有关
	- 半顺序（直接）存取存储器
		- 沿磁道方向顺序存储
		- 垂直半径方向随机存取
- 读写功能分类
	- 只读存储器 ROM Read Only Memory
	- 随机存取存储器 RAM Random Access Memory
- 信息易失性分类
	- 易失性存储器
	- 非易失性存储器
- 与 CPU 耦合度分类
	- 内部存储器
		- 主存
			- ROM
				- 存储不变或基本不变的程序和数据（监控程序、引导加载程序及常数表格等）。
			- RAM
				- 存储当前运行的程序和数据，可在运行过程中反复更改其内容。
				- 静态 RAM（SRAM）
					- 半导体管导通/截止
					- 掉电则信息丢失
				- 动态 RAM（DRAM）
					- 电荷存储在电荷中
					- 电荷会随时间漏掉，需要周期性刷新
						- 掩膜 ROM
						- 一次可编程 ROM（PROM）
						- 可擦除 PROM（EPROM）
							- 紫外线擦除 EPROM（UV-EPROM）
							- 电擦除 EPROM（EEPROM/$E^2PROM$）
							- 闪速 ROM（Flash）
		- 高速缓冲存储器
	- 外部存储器
### 3.1.3 存储器的编址和端模式
- 字存储单元
	- 存放一个机器字的存储单元
	- 字地址
- 字节存储单元
	- 存放一个字节的单元
	- 字节地址
- 端模式
	- ![存储器的端模式实例|371](https://cdn.jsdelivr.net/gh/aBER0724/ob_picture/Img/20240607081303.png)
	- 当一个存储字的字长高于八位时，在一个存储字内部的多字节的排列顺序。
	- 大端模式
		- 将一个字的高有效字节放在内存的低地址端。
	- 小端模式
		- 将一个字的低有效字节放在内存的低地址端。
- 3.1.4 存储器的技术指标
- 存储容量
	- 存储信息比特数。
	- 单位
		- bit
		- B
		- KB
		- MB
		- GB
		- TB
	- $1TB = 2^{10} GB = 2^{20} MB = 2^{30} KB = 2^{40} B$
	- 表示方法
		- $1M \times 1bit$
		- $128K \times 8bit$
		- $512K \times 4bit$
- 存取时间
	- 存储器访问时间。
	- 存储器接收到读/写命令→信息被读出/写入完成的时间。
	- 取决于存储介质的物理特性和寻址部件的结构。
- 存储周期（存取周期）
	- 存储器连续读写过程中一次完整的存取操作所需的时间。
	- CPU 连续两次访问存储器的最小间隔时间。
	- 通常存储周期略大于存取时间。
- 存储器带宽（数据传送速率，频宽）
	- 单位时间内存储器所存取的信息量。
	- 位/秒，字节/秒
	- 总线宽度 W 位，$带宽= \frac{W}{存储周期}$

## 3.2 静态随机存取存储器
- SRAM 存取速度快，但存储密度和容量不如 DRAM 大。
### 3.2.1 基本静态存储元阵列
- ![基本的静态存储元阵列|405](https://cdn.jsdelivr.net/gh/aBER0724/ob_picture/Img/20240607082503.png)
- 控制线控制读写操作（读写操作不会同时发生）
- $存储单元数 = 2^{地址线数}$
- $存储位元总数 = 存储单元数 \times 存储器字长$
### 3.2.2 基本的 SRAM 逻辑结构
- ![32K×8位SRAM结构图和逻辑图|432](https://cdn.jsdelivr.net/gh/aBER0724/ob_picture/Img/20240607083213.png)
- 地址线 15 条
	- x 方向 8 条，行译码 $2^8$ 行
	- y 方向 7 条，列译码 $2^7$ 列
	- $存储阵列 = 2^8 行 \times 2^7 列 \times 8 位$
- 片选信号 $\overline{CS}$
	- 低电平有效，$G_1$ 和 $G_2$ 打开
- 信号
	- 读出信号 $\overline{OE} = 0$ （低电平有效），$G_2$ 开启
	- 写命令 $\overline{WE} = 1$ （高电平有效），$G_1$ 关闭
	- $G_1$ 和 $G_2$ 互锁，保证读写不同时发生。
- 操作
	- 读操作
		- $\overline{CS} = 0, \overline{OE} = 0, \overline{WE} = 1$
		- $G_2开启，G_1关闭$
	- 写操作
		- $\overline{CS} = 0, \overline{OE} = 1, \overline{WE} = 0$
		- $G_2关闭，G_1开启$
### 3.2.3 SRAM 读/写时序
- ![SRAM 读/写周期时序图|345](https://cdn.jsdelivr.net/gh/aBER0724/ob_picture/Img/20240607085853.png)
- 读周期时间
- 写周期时间
- 存取周期
- 3.2.4 存储器容量的扩充
- 位扩展
	- 给定芯片的字数符合要求，但位数较短。
	- 1M × 4位的 SRAM 芯片设计一个 1M × 8位的 SRAM 存储器。
	- 所需芯片数 $d = \frac{1M \times 8}{1M \times 4} = 2(片)$
- 字扩展
	- 给定芯片的存储容量较少（字数少）。
	- 256K × 8位的 SRAM 芯片设计 2048K × 8位存储器。
	- 所需芯片数 $d = \frac{2048K \times 8}{256K \times 8} = 8(片)$
- 字位扩展
	- 先位扩展，再字扩展。

## 3.3 动态随机存储器
### 3 .3.4 DRAM 刷新操作
- 刷新周期
	- 主流刷新间隔时间为 64 ms。
- 集中式刷新策略
	- 每个刷新周期集中一段时间对 DRAM 的所有行进行刷新。
		- 前一段时间进行正常读写操作。
		- 后一段连续刷新所有行。
			- 死时间
				- 由于刷新过程中不允许读写，所以存在死时间。
- 分散式刷新策略
	- 每隔 $\frac{刷新周期}{行数}$ 时间，刷新一行。
		- 64 ms，8192 行，$\frac{64ms}{8192} = 7.8 \mu s$, 每隔 $7.8 \mu s$ 刷新一行。
- 存储器控制器或 DRAM 控制器
	- 产生 DRAM 访问和刷新时序控制与地址信号。

## 3.6 cache 存储器
### 3.6.1 cache 基本原理
- cache 功能
	- ![CPU与存储器系统的关系|371](https://cdn.jsdelivr.net/gh/aBER0724/ob_picture/Img/20240607093430.png)
	- 高速缓冲存储器
	- 解决 CPU 与主存之间速度不匹配的问题。
- cache 的基本原理
	- ![image.png|342](https://cdn.jsdelivr.net/gh/aBER0724/ob_picture/Img/20240607093916.png)
	- CPU 读取内存内存某个字时，将其内存地址发送到 cache 和主存，
		- cache 控制逻辑根据地址判断该字是否存在 cache 中。
			- 若存在则 cache 命中，立即将此字传送给 CPU。
			- 若不存在则 cache 缺失，用主存读周期将此字读取给 CPU，同时将含有此字的整个数据块送到 cache 中。
- cache 命中率
	- 命中率 $h = \frac{N_c}{N_c + N_m}$
		- cache 完成存取的次数 1900 次，主存完成存取次数 100 次。cache 存取周期 50 ns，主存存取周期 250 ns。
			- $h = \frac{N_c}{N_c+N_m} = \frac{1900}{1900+100} = 0.95$
			- $r = \frac{t_m}{t_c} = \frac{250 ns}{50 ns} = 5$
			- $e = \frac{1}{r+(1-r) h} = \frac{1}{5+(1-5) \times 0.95} = 83.3\%$
			- $t_a = \frac{t_c}{e} = \frac{50 ns}{0.833} = 60 ns$
	- cache/主存系统的平均访问时间 $t_a = ht_c + (1-h)t_m$
	- 访问效率 $e = \frac{t_c}{t_a} = \frac{t_c}{ht_c+(1-h)t_m} = \frac{1}{h+(1-h)r} = \frac{1}{r+(1-r)h}$
		- 主存与 cache 的访问时间比 $r = \frac{t_m}{t_c}$
- cache 结构必须解决的问题
	- cache 的命中率尽可能高
	- cache 对 CPU 是透明的
	- 地址映射
		- 使用某种方法把主存地址定位到 cache 中。
	- cache 地址变换
		- CPU 给出一个字的内存地址可以自动变换成 cache 的地址。
### 3.6.2 主存与 cache 的地址映射
- 全相联映射方式
	- ![全相联映射的cache组织|317](https://cdn.jsdelivr.net/gh/aBER0724/ob_picture/Img/20240607194516.png)
	- 行
		- cache 的数据块大小
		- $m=2^r行$
	- 块
		- 主存的数据块大小
		- $n=2^s 块$
	- 行和块等长，有 k 个连续的字组成。
- 直接映射方式
	- ![直接映射的 cache 组织|435](https://cdn.jsdelivr.net/gh/aBER0724/ob_picture/Img/20240607195352.png)
	- $i = j \ mod \ m$
		- $i$
			- cache 行号
		- $j$
			- 主存块号
		- $m$
			- cache 总行数
- 组相联映射方式
	- ![组相联映射的 cache 组织|410](https://cdn.jsdelivr.net/gh/aBER0724/ob_picture/Img/20240607200242.png)
	- cache
		- 分为 $m = u \ 组 \times v \ 行$
			- $v$ 一般取值较小，典型值：2/4/8/16
		- 组号 $q= j \ mod \ u$
### 3.6.3 cache 的替换策略
#### 最不经常使用 LFU 算法
#### 近期最少使用 LRU 算法
#### 随机替换
#### 计算 - 算命中率
### 3.6.5 Pentium 4 的 cache 组织
- ![image.png|429](https://cdn.jsdelivr.net/gh/aBER0724/ob_picture/Img/20240613205309.png)
- 四个组成部件
	- 取值/ 译码单元
		- 按需从 $L_2$ cache 中取值
		- 转译成一系列微指令
		- 存入 $L_1$ 指令 cache
	- 乱序执行逻辑
		- 依据数据相关性和资源可用性进行调度微指令执行
		- 而不是取值前后而执行
	- 执行单元
		- 执行微指令
		- 从 $L_1$ 数据 cache 中取数据
		- 在寄存器组中暂存运算结果
	- 存储器子系统
		- $L_2$ cache 
		- $L_3$ cache
		- 系统总线
			- $L_1$ 和 $L_2$ cache 未命中时，访问主存
			- 访问 I/O 资源
### 3.6.6 使用多级 cache 减少缺失损失
- 需要逐级向上查找，每次访问不同等级的 cache 的时间，即确实损失
## 3.7 虚拟存储器
### 3.7.1 虚拟存储器概念
- 实
	- 实地址/物理地址
		- 计算机物理内存的访问地址
	- 虚存空间/逻辑地址空间
- 虚
	- 虚地址/逻辑地址
		- 用户编制程序时使用的地址
	- 物理存储空间/主存空间
- 虚存访问过程
	- 虚存空间的程序先按虚地址编程，存在辅存中
	- 程序运行时，地址变换机构依据分配的实地址空间把程序的一部分调入实存
	- 每次访存，首先判断该虚地址对应部分是否在实存中
		- 若存在，则地址转换并使用实地址访问主存
		- 若不存在，则按某个算法将辅存中的部分程序调入内存，再按相同方法访问主存
- 虚存的使用
	- 多用户/多任务系统
		- 虚地址空间远小于实地址空间
			- 用于地址变换
	- 单个任务
		- 虚地址空间远大于实地址空间
			- 用于提高存储用量
- 虚存作用
	- 程序可以透明的使用整个虚存空间
	- 每个程序都拥有一个虚拟存储器
		- 具有辅存容量
		- 接近驻村的访问速度
- cache 和虚存的对比
	- 相同点
		- 出发点-提高性能
		- 原理-局部性原理
	- 不同点
		- 侧重点
			- cache-主存与 CPU 间的速度差异
			- 虚存-提高存储容量
		- 数据通路
			- cache、主存和 CPU 间有直接通路
			- 虚存依赖辅存，不存在直接通路，未命中时 CPU 仍要访问主存
		- 透明性
			- cache-由硬件完成，对系统程序员和应用程序员均透明
			- 虚存-有软件的介入，对应用程序员透明，对系统程序员不透明
		- 未命中时的损失
			- 主存未命中时系统的性能损失远大于 cache 未命中时的损失
- 虚存需要解决的问题
	- 调度问题
	- 地址映射问题
	- 替换问题
	- 更新问题
### 3.7.2 页式虚拟存储器
- 页式虚存地址映射
	- 页：地址空间分成等长的页
		- 逻辑页：虚存
			- 虚地址
				- 高字段：逻辑页号
				- 低字段：页内地址（偏移量）
		- 物理页：主存
			- 实地址
				- 高字段：物理页号
				- 低字段：页内地址
	- 页表：每个进程对应一个页表
		- ![image.png|370](https://cdn.jsdelivr.net/gh/aBER0724/ob_picture/Img/20240615215533.png)
- 转换后援缓冲器 TLB
	- ![image.png|376](https://cdn.jsdelivr.net/gh/aBER0724/ob_picture/Img/20240615215940.png)
	- 转换后援缓冲器 TLB（快表）：专用于页表缓存的高速存储部件
	- 慢表：保存在主存中的完整页表
	- TLB 的作用类似 cache 的作用
		- 存储慢表中的部分信息，可进行高速检索
- 虚存、TLB 和 cache 间的协同操作
	- 最好的情况
		- TLB 转换虚拟地址，送入 cache，CPU 取回数据
	- 最坏的情况
		- TLB、页表和 cache 都缺失
	- 情况组合
		- ![image.png|594](https://cdn.jsdelivr.net/gh/aBER0724/ob_picture/Img/20240616162156.png)
### 3.7.3 段式虚存和段页式虚存
- 段式虚拟存储器
	- ![image.png|285](https://cdn.jsdelivr.net/gh/aBER0724/ob_picture/Img/20240616162600.png)
	- 段：按程序自然分界划分长度（动态区域）
	- 段表
		- 有效位
		- 段起址
		- 段长
	- 特点
		- 优点
			- 逻辑更利于编译、管理、修改和保护，以及多道程序共享
			- 段长可动态变化，有效利用主存空间
		- 缺点
			- 主存空间分配较麻烦
			- 容易在段间留下碎片，空间利用率降低
			- 段长不一定为 2 的倍数，需要特殊操作
- 段页式虚拟存储器
	- ![image.png](https://cdn.jsdelivr.net/gh/aBER0724/ob_picture/Img/20240616163445.png)
	- 结合段式和页式
	- 通过一个段表和多个页表进行两次定位
	- 虚地址组成
		- ![image.png|471](https://cdn.jsdelivr.net/gh/aBER0724/ob_picture/Img/20240616163322.png)
### 3.7.4 虚存的替换算法
- 虚存替换与 cache 替换的不同
	- cache 全部由硬件实现，虚存的替换有 OS 的支持
	- 虚存缺页对系统性能的影响比 cache 大得多
		- 调页需要访问辅存
		- 需要进行任务切换
	- 虚存的替换选择很大，属于一个进程的页面都可以替换
### 3.7.5 存储管理部件
- 存储管理部件 MMU
- 功能
	- 在 TLB 的协助下完成虚实地址转换
	- 维护 TLB 的控制机制
	- 负责存储保护
	- TLB 失效或非法访问时向 CPU 发起中断
	- 维护一个 TLB 失效后的在填充机制
- 工作流程
	- CPU 发出访存的地址
	- MMU 通过页表查询机制访问主存页表，获得映射关系
		- 命中，MMU 将虚页号转换为物理页号，产生物理地址访存
		- 未命中（主存缺页），CPU 将转到 OS 的页面失效程序入口，OS 进行调页操作