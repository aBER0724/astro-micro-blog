---
title: "Computer Composition Review Ch2 运算方法和运算器"
date: 2024-06-16
---

## 2.1 数据和文字的表示方法
### 2.1.1 数据格式
- 定点数
	- 表示成纯小数/纯整数
		- 形式：$x_n \ x_{n-1} \ x_{n-1} \  \dots \ x_1 \ x_0$
			- $x_n$ 为符号
			- $x_{n-1} \ x_{n-1} \  \dots \ x_1 \ x_0$ 为量值（尾数）
	- 纯小数
		- 小数点在 $x_n$ 和 $x_{n-1}$ 之间
		- $0 < |x| < 1-2^{-n}$
	- 纯整数
		- 小数点在 $x_0$ 右边
		- $0<|x|<2^n-1$
- 浮点数
	- 浮点数表示法
		- 十进制 $N=10^E.M$
		- 二进制 $N=2^e.M$
		- 尾数 $M$
		- 指数 $E$
	- 机器浮点数标识
		- $E_s \ | \ E_{m-1} \ \dots \ E_1 \ E_0 \ | \ M_s \ | \ M_{n-1} \ \dots \  M_1 \ M_0$
			- $E_s$ : 阶符，指数正负
			- $E_{m-1} \ \dots \ E_1 \ E_0$ : 阶码，指数
			- $M_s$ : 数符，浮点数正负
			- $M_{n-1} \ \dots \ M_1 \ M_0$ : 尾数
### 2.1.2 机器码表示
- 正整数
	- 原码=反码=补码
- 负整数
	- 反码=原码取反（不包括符号位）
	- 补码=反码+1
- 0 表示
	- 原码
		- 00000000
		- 10000000
	- 反码
		- 00000000
		- 11111111
	- 补码
		- 00000000
		- 0 在补码表示法中有唯一的表示
- 移码表示
	- 符号位与原反补码相反
		- 1 为正
		- 0 为负
	- $[e]_移=2^k+e,\ 2^k>e \geq -2^k$
		- $e$ 为真值
		- $2^k$ 为固定的偏移值常数（$k$ 为阶码位数）
- 浮点数机器表示
	- 32 位短浮点数
		- 符号 $S$ ：1 位
		- 阶码 $E$ ：8 位
		- 尾数 $M$：23 位
		- 指数偏移值：127
	- 64 位长浮点数
		- 符号 $S$ ：1 位
		- 阶码 $E$ ：11 位
		- 尾数 $M$：52 位
		- 指数偏移值：1023
	- 浮点数规格化表示
		- $x=(-1)^S \times (1.M) \times 2^{E-偏移常数}, \ e = E-偏移常数$
### 2.1.3 字符与字符串表示
- 字符
	- ASCII
	- 8 位，最高位为 0
- 字符串
	- 存在主存中连续的多字节
### 2.1.4 汉字表示
- 输入编码（输入）
	- 数字编码
		- 区位码（94 个区，94 位，二维数组）
	- 拼音码
	- 字形编码
		- 笔画顺序
- 汉字内码（内部处理）
	### 2.字节最高为均为 1，与英文字符进行区别
	- 若最高位用于奇偶校验位，则使用 3 字节
- 汉字字模码（输出）
	- n x n 的点阵
### 2.1.5 校验码
- 奇校验位 $\overline C$
	- $\overline C=x_0 \oplus x_1 \oplus \dots \oplus x_{n-1}$
	- X 中包含奇数个 1 时, $\overline C = 1$
- 偶校验位 $C$
	- $C=x_0 \oplus x_1 \oplus \dots \oplus x_{n-1}$
	- X 中包含偶数个 1 时, $C = 1$
- 奇偶校验进提供奇数个错误检测，无法检测偶数个错误，也无法定位错误位置。

## 2.2 定点加法、减法运算
### 2.2.1 补码加法
- 补码相加，结果再转回原码。
### 2.2.2 补码减法
- 将减数转成负数后进行加法运算（补码加法）。
	- $[x]_补 - [y]_补 = [x]_补 + [-y]_补$
### 2.2.3 溢出及检测
- 溢出
	- 运算过程中，出现大于字长绝对值的现象。
	- 正溢
		- 大于机器字长能表示的最大正数。
	- 负溢
		- 小于机器字长能表示的最小负数。
- 变形补码
	- 双符号位
		- 00→01
			- 正溢出
		- 11→10
			- 负溢出
### 2.2.4 基本二进制加法/减法器
- $S_i = A_i \oplus B_i \oplus C_i$
- $C_{i+1} = A_iB_i+B_iC_i+C_iA_i$

## 2.3 定点乘法运算
- 乘法运算
	- 与十进制一样
		- 每位依次与另一个乘数相乘再相加。
- 不带符号的阵列乘法器
	- 组成部分
		- 加法器
		- 移位器
	- 对于两个n位数的乘法
		- 需要的全加器 $n(n-1)$
		- 需要的与门 $n^2$
- 带符号的阵列乘法器
	- 符号扩展求补器
	- 不带符号的乘法阵列
	- 溢出处理求补器

## 2.4 定点除法运算
- 基础运算与十进制一样
	- 恢复余数法
	- 加减交替法

## 2.5 定点运算器的组成
### 2.5.1 逻辑运算
- 逻辑非
	- 按位取反
	- $01001011 \rightarrow 10110100$
- 逻辑加/或 $+$
	- $10100001 + 10011011 = 10111011$
- 逻辑乘/与 $\cdot$
	- $10111001 \cdot 11110011 = 10110001$
- 逻辑异/按位加 $\oplus$
	- $10101011 \oplus 11001100 = 01100111$
### 2.5.2 多功能算术/逻辑运算单元 ALU
- 使用不同的控制参数得到不同的组合函数，实现多种算术运算和逻辑运算。
	- $F_i = X_i \oplus Y_i \oplus C_{n+i}$
	- $C_{n+i=1} = X_iY_i+Y_iC_{n+i} + C_{n+i}X_i$

## 2.6 浮点运算方法和浮点运算器
### 2.6.1 浮点加减法
- $z = x \pm y = (M_x2^{E_x - E_y} \pm M_y)2^{E_y}, \ E_x \leq E_y$
	- $x = 2^{E_x} \cdot M_x$
	- $y = 2^{E_y} \cdot M_y$
- 计算流程
	- 0 操作数检查
		- 检查是否有 0 只，节省运算时间。
	- 比较阶码大小并完成对阶
		- 小数点位置是否对齐。
		- 小阶向大阶看齐。
			- 小数点左移一位，阶码+1
	- 尾数加减运算
	- 结果规格化
		- 结果溢出
		- 向右规格化
		- 向左规格化
	- 舍入处理
		- 尾数右移，最低位会被丢掉，造成误差。
		- 就近舍入
			- 四舍五入
		- 朝 $0$ 舍入
			- 简单截尾
		- 朝 $+ \infty$ 舍入
			- 正数
				- 多余位不全为 0，则向最低有效位进 1.
			- 负数
				- 简单截尾
		- 朝 $- \infty$ 舍入
			- 负数
				- 多余位不全为 0，则向最低有效位进 1.
			- 正数
				- 简单截尾
	- 溢出处理
		- 阶码上溢
			- 超过阶码能表示的最大值的正指数值，将其认为 $+\infty$ 和 $-\infty$。
		- 阶码下溢
			- 超过阶码能表示的最小值的负指数值，将其认为 0。
		- 尾数上溢
			- 最高位有进位，尾数右移，阶码+1 重新对齐。
		- 尾数下溢
			- 尾数右移，最低有效位进行舍入处理。
### 2.6.2 浮点乘除法
- $x \times y = 2^{(E_x+E_y)} \cdot (M_x \times M_y)$, $x \div y = 2^{(E_x-E_y)} \cdot (M_x \div M_y)$
	- $x = 2^{E_x} \cdot M_x$
	- $y = 2^{E_y} \cdot M_y$
- 计算步骤
	- 浮点数的阶码运算
		- 指数相加并用移码表示
		- $E_x + E_y$
	- 尾数相乘
- Example
	- $R=10, \ x = 10^{E_x} \times M_x = 10^2 \times 0.4, \ y = 10^{E_y} \times M_y = 10^3 \times 0.2$
	- $x \times y = 10^{2+3} \times (0.4 \times 0.2) = 8000$
	- $x \div y = 10^{2-3} \times (0.4 \div 0.2) = 0.2$
### 2.6.3 浮点运算流水线?

## 2.2 定点加法、减法运算
- 2.2.1 补码加法
	- 补码相加，结果再转回原码。
- 2.2.2 补码减法
	- 将减数转成负数后进行加法运算（补码加法）。
		- $[x]_补 - [y]_补 = [x]_补 + [-y]_补$
- 2.2.3 溢出及检测
	- 溢出
		- 运算过程中，出现大于字长绝对值的现象。
		- 正溢
			- 大于机器字长能表示的最大正数。
		- 负溢
			- 小于机器字长能表示的最小负数。
	- 变形补码
		- 双符号位
			- 00→01
				- 正溢出
			- 11→10
				- 负溢出
- 2.2.4 基本二进制加法/减法器
	- $S_i = A_i \oplus B_i \oplus C_i$
	- $C_{i+1} = A_iB_i+B_iC_i+C_iA_i$

## 2.3 定点乘法运算
- 乘法运算
	- 与十进制一样
		- 每位依次与另一个乘数相乘再相加。
- 不带符号的阵列乘法器
	- 组成部分
		- 加法器
		- 移位器
	- 对于两个n位数的乘法
		- 需要的全加器 $n(n-1)$
		- 需要的与门 $n^2$
- 带符号的阵列乘法器
	- 符号扩展求补器
	- 不带符号的乘法阵列
	- 溢出处理求补器

## 2.4 定点除法运算
- 基础运算与十进制一样
	- 恢复余数法
	- 加减交替法

## 2.5 定点运算器的组成
- 2.5.1 逻辑运算
	- 逻辑非
		- 按位取反
		- $01001011 \rightarrow 10110100$
	- 逻辑加/或 $+$
		- $10100001 + 10011011 = 10111011$
	- 逻辑乘/与 $\cdot$
		- $10111001 \cdot 11110011 = 10110001$
	- 逻辑异/按位加 $\oplus$
		- $10101011 \oplus 11001100 = 01100111$
- 2.5.2 多功能算术/逻辑运算单元 ALU
	- 使用不同的控制参数得到不同的组合函数，实现多种算术运算和逻辑运算。
		- $F_i = X_i \oplus Y_i \oplus C_{n+i}$
		- $C_{n+i=1} = X_iY_i+Y_iC_{n+i} + C_{n+i}X_i$

## 2.6 浮点运算方法和浮点运算器
- 2.6.1 浮点加减法
{ #3c1010b6-8af8-a6f9}

	- $z = x \pm y = (M_x2^{E_x - E_y} \pm M_y)2^{E_y}, \ E_x \leq E_y$
		- $x = 2^{E_x} \cdot M_x$
		- $y = 2^{E_y} \cdot M_y$
	- 计算流程
		- 0 操作数检查
			- 检查是否有 0 只，节省运算时间。
		- 比较阶码大小并完成对阶
			- 小数点位置是否对齐。
			- 小阶向大阶看齐。
				- 小数点左移一位，阶码+1
		- 尾数加减运算
		- 结果规格化
			- 结果溢出
			- 向右规格化
			- 向左规格化
		- 舍入处理
			- 尾数右移，最低位会被丢掉，造成误差。
			- 就近舍入
				- 四舍五入
			- 朝 $0$ 舍入
				- 简单截尾
			- 朝 $+ \infty$ 舍入
				- 正数
					- 多余位不全为 0，则向最低有效位进 1.
				- 负数
					- 简单截尾
			- 朝 $- \infty$ 舍入
				- 负数
					- 多余位不全为 0，则向最低有效位进 1.
				- 正数
					- 简单截尾
		- 溢出处理
			- 阶码上溢
				- 超过阶码能表示的最大值的正指数值，将其认为 $+\infty$ 和 $-\infty$。
			- 阶码下溢
				- 超过阶码能表示的最小值的负指数值，将其认为 0。
			- 尾数上溢
				- 最高位有进位，尾数右移，阶码+1 重新对齐。
			- 尾数下溢
				- 尾数右移，最低有效位进行舍入处理。
- 2.6.2 浮点乘除法
	- $x \times y = 2^{(E_x+E_y)} \cdot (M_x \times M_y)$, $x \div y = 2^{(E_x-E_y)} \cdot (M_x \div M_y)$
		- $x = 2^{E_x} \cdot M_x$
		- $y = 2^{E_y} \cdot M_y$
	- 计算步骤
		- 浮点数的阶码运算
			- 指数相加并用移码表示
			- $E_x + E_y$
		- 尾数相乘
	- Example
		- $R=10, \ x = 10^{E_x} \times M_x = 10^2 \times 0.4, \ y = 10^{E_y} \times M_y = 10^3 \times 0.2$
		- $x \times y = 10^{2+3} \times (0.4 \times 0.2) = 8000$
		- $x \div y = 10^{2-3} \times (0.4 \div 0.2) = 0.2$
- 2.6.3 浮点运算流水线?